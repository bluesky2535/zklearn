###设计原则
1. 单一职责原则
2. 里氏替换原则
    - 对继承的规范，即子类可以调用父类方法，父类不能调用子类
3. 依赖倒置原则
    - 不使用依赖倒置原则将会加重类之间的耦合性，降低系统的稳定性
    - 不使用依赖倒置原则将会增加并行开发引起的风险
    - 依赖接口编程，可以使用测试驱动开发
    - 依赖注入的三种写法：
        - 构造函数注入;
        - set方法注入;
        - 接口方法注入;
    - 最佳实践
        - 每个类尽量都有接口或抽象类
        - 变量的表面类型尽量是接口或者抽象类
        - 任何类都不应该从具体的类派生
        - 尽量不要覆写基类的方法
        - 结合里氏替换原则使用
 4. 接口隔离原则
    -  不应该使接口臃肿提供给各个模块使用，而是应该各个模块有各个专门的接口
    - 接口隔离原则有4层定义：
        - 接口要尽量小
        - 接口要高内聚
        - 定制服务
        - 接口设计是要有限度的
 5. 迪米特法则
    - 类方法中不能与其他陌生类有依赖关系，尽量不要引入一个类中不存在的对象
    - 类与类之间尽量不要耦合度高，要明确类方法内的逻辑的类归属关系，分清职责
 6. 开闭原则
    - 对扩展开放，对修改关闭
    - 开闭原则的重要性
        - 不修改原有代码，减少测试人员的修改
        - 可以提高复用性，逻辑粒度小，可以提高复用率
        - 开闭原则可以提高可维护性，维护人员更喜欢扩展一个类，而不是在原有代码中查找修改
        - 面向对象开发的要求
        - 是6大设计原则之首，可以将其他原则简称为SOLID原则,即每个原则的首字母
            - Single 单一设计原则
            - Open   开闭原则
            - Liskov 里氏替换法则
            - Law of Demeter 迪米特法则
            - Interface 接口隔离法则
            - Dependence 依赖倒置法则
    - 如何使用开闭原则：
        - 抽象约束
            - 通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法；
            - 参数类型、引用对象尽量使用接口或者抽象类，而不是实现类
            - 抽象层尽量保持稳定，一旦确定即不允许修改
        - 元数据控制模块行为
            - 描述环境和数据的数据，做到灵活扩展
        - 制定项目章程，约束团队行为
        - 封装变化
            - 将相同的变化封装到一个接口或抽象类中
            - 将不同的变化封装到不同的接口或抽象类中
###单例模式
1. 只产生一个实例
    ```java
    public class Single {
        private static  Single single=new Single();
        private Single(){
    
        }
        public static Single getInstance(){
            return single;
        }
    }
    ```             
2. 应用
    - 优点: 节省内存
    - 缺点: 难于扩展，需求变化时，只能修改源代码
    - 使用场景: 在系统中有一个类且仅有一个对象
    - 注意事项: 在并发情况下，需要注意线程不安全可能会产生多个实例的问题      
3. 扩展
    - 当有需要指定数量的实例时，则需要在获取实例方法中通过随机访问的方式返回实例
4. 最佳实践
    - Spring容器中创建Bean,默认就是单例模式，可以管理bean的整个生命周期，如果采用多例模式。则会转移控制权，由J2EE容器去管理
###工厂方法模式
1. 基本结构
    - 抽象工厂方法
    - 实例工厂方法
    - 抽象产品
    - 实例产品
    - 客户端
2. 扩展
    - 简单工厂模式
    - 如果产品类型过多，则可以扩展为多工厂模式
    - 可以将工厂模式改装为单例模式
    - 延迟加载的工厂类，在创建的产品逻辑中进行判断 
###抽象工厂模式
1. 基本结构
    - 基本结构是工厂方法模式的扩展，对产品种类的细分，可扩展为产品族的概念
2. 优点
    - 封装性，高层模块只需要掌握需要什么样的产品，而底层细节由工厂类去处理
3. 缺点
    - 产品族扩展困难,增加一个产品，导致多个实现类都要添加创建该产品的实现    
###模板方法模式
1. 基本结构
    - 抽象类中有基本方法和模板方法
        - 基本方法:基本操作，一般由子类去实现，并且在模板方法中调用
        - 模板方法: 可以有一个或多个，一般是具体方法，实现对基本方法的调用，有着固定的逻辑
2. 优点  
    - 封装不变的部分，扩展可变的部分
    - 提取公共的代码，便于维护
    - 行为由父类控制，子类实现  
3. 缺点
    - 模板方法模式颠倒了实现类完成具体的事务属性和方法
4. 使用场景
    - 多个子类使用同一套算法
5. 扩展
    - 由客户端控制模板方法的运行情况，可以通过设置属性参数来控制，然后通过返回的属性参数，去影响模板方法的运行，称之为钩子方法           
        
###建造者模式
1. 基本结构
    - 抽象的产品
    - 实际的产品
    - 建造者:控制建造的顺序
    - 导演     
2. 优点
    - 封装性:使用建造者模式可以使客户端不必知道产品内部的细节
    - 建造者独立，容易扩展
    - 便于控制细节风险:建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响
3. 使用场景
    - 相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式
4. 注意
    - 建造者模式关注的是零件类型和装配顺序，这是它与工厂方法模式最大不同的地方，虽然同为创建类模式，但是注重点不同
###代理模式
1. 基本结构
    - 抽象主题角色
    - 具体主题角色
    - 代理主题角色
2. 代理模式优点
    - 职责清晰，真实角色就是实现实际的业务逻辑，不用关心其他非本职责的事务
    - 高扩展性，具体主题可以任意变化，却不影响代理类的操作
3. 扩展
    - 普通代理:即客户端不创建真实角色，而在代理类中创建相关真实角色，对上层屏蔽真实角色的实现
    - 强制代理:必须使用代理才能使用    
    - 动态代理:不需要
###原型模式
1. 基本结构
    - 通过实现CloneAble接口的clone方法，完成对象在内存二进制流形式的拷贝
    - 拷贝对象实例时，需要注意不会执行构造方法的逻辑   
2. 优点
    - 性能优良，在内存二进制流拷贝，比直接new一个对象性能好很多
    - 逃避构造函数的约束
3. 使用场景
    - 资源优化场景
    - 性能和安全要求的场景
    - 一个对象多个修改这的场景，一般和工厂方法模式一起出现，通过clone方法创建一个对象，然后由工程方法提供给调用者
4. 注意事项
    - 构造函数不会执行
    - 浅拷贝
        - 浅拷贝只拷贝对象，但是其对象内部的数组、引用对象都不拷贝，还是指向原生对象的内部元素地址。
        - 原始类型如int、long、char等会被拷贝
    - 深拷贝
        - 对对象的引用数据进行深拷贝
            ```java
              @Override
               protected Prototype clone() throws CloneNotSupportedException {
                   Prototype p = (Prototype) super.clone();
                   //对对象中的引用数据进行深拷贝
                   p.arrayList = (ArrayList<String>) this.arrayList.clone();
              
                   return p;
               }
            ```
    - clone和final是冲突的
        - 如果需要深拷贝的变量加上final关键字，则编译器会报错，两者只能选其一
###中介模式
1. 基本结构
    - Mediator抽象中介者角色
    - Concrete Mediator 具体中介者角色
    - Colleague 同事角色
    - 每一个同事角色都知道中介者角色，与其他同事角色通信时，一定通过中介者角色协作
    - 同事类的行为分为两种：
        - 同事本身的行为，也叫自发行为
        - 必须依赖中介者才能完成的行为，叫做依赖方法
2. 优点
    - 减少类间的依赖，把原有的一对多的依赖编程了一对一的依赖，同事类只依赖中介者,降低了类间的耦合
3. 缺点
    - 中介者会膨胀的很大，同事类越多，中介者的逻辑就会越复杂
4. 使用场景
    - 不代表有多个依赖关系就要使用中介者模式，要量力而行
    - 多个对象之间发生了紧耦合的情况下，如形成蜘蛛网结构，有利于梳理为星状结构
5. 实际应用
    - 机场调度中心
    - MVC框架
    - 媒体网关
    - 中介服务
6. 实践
    - N个对象之间产生了相互依赖的关系（N>2）,多个对象有依赖关系，但是依赖的行为尚不确定或者有可能发生改变的情况下，可以使用中介者模式   
###命令模式
1. 基本结构
    - 接收者：处理具体业务逻辑
    - 命令角色：需要执行的所有命令都在这里声明
    - 调用者角色
2. 优点
    - 类间解耦
        - 调用者与接收者角色之间没有任何依赖关系，调用者实现功能时只需调用Command抽象类的execute方法就可以，不需要了解到底哪个接收者执行
    - 可扩展性
        - Command的子类可以非常容易地扩展，而调用者Invoker和高层次的Client不产生严重的代码耦合
    - 命令模式 
        - 命令模式可以结合责任链模式，实现命令族解析任务，结合模板方法模式，则可以减少Command子类的膨胀问题
3. 缺点
    - 命令模式中有N个命令，就会有N个Command子类
###责任链模式
1. 基本结构
    - 抽象处理者
        - 定义一个请求的处理办法handleMessage
        - 定义一个链的编排方法setNext
    - 实际处理者
    - 客户端
2. 优点        
    - 显著的优点就是将请求和处理分开
    - 处理者不需要清楚请求的全貌
3. 缺点
    - 每个请求都从链头遍历到链尾。耗费性能
    - 调试不方便，当链条比较长时，调试逻辑会比较复杂
4. 注意事项
    - 链条的节点数量不能过多，需要设置阈值   
###装饰器模式
1. 定义：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式相比生成子类更为灵活
2. 结构
    - Component 抽象构件
    - ConcreteComponent具体构件
    - Decorator装饰角色
    - 具体装饰角色
3. 优点
    - 装饰类和被装饰类可以独立扩展，而不会耦合。Component类和Decorator类可以互相不了解对方
4. 缺点
    - 多层的装饰是比较复杂的，发现问题比较麻烦，应该减少装饰类的数量，以便降低系统的复杂度
5. 使用场景
    - 需要扩展一个类的功能，或者给一个类增加附加功能
    - 需要动态地给一个对象增加功能，功能可以动态的撤销
    - 给一批兄弟类进行改装或加装功能，当然首选装饰模式
###策略模式
1. 定义
    - 定义一组算法，将每个算法都封装起来，并且使它们之间可以互换
2. 基本结构
    - Context封装角色
    - Strategy抽象策略角色
    - ConcreteStrategy具体策略角色
3. 优点
    - 算法可以自由切换
    - 避免多条件的判断
    - 扩展功能方便，只需要实现策略接口即可
4. 缺点
    - 策略类数量过多，复用可能性小
    - 所有策略都对外暴露，与迪米特法则相违背
5. 使用场景
    - 多个类只有在算法或行为上有不同的场景
    - 算法需要自由切换的场景
    - 需要屏蔽算法规则的场景
6. 注意事项
    - 系统的策略类最好不要超过4个，需要考虑混合模式，解决策略类膨胀和对外暴露问题
###适配器模式
1. 定义
    - 将一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法在一起工作的两个类能够一起工作
2. 基本结构
    - Target目标角色
    - Adaptee源角色
    - Adapter适配器角色
3. 优点
    - 将两个没有任何关系的类在一起运行，适配器去做处理
    - 增加了类的透明性,
    - 增加了类的复用度
    - 灵活性好
4. 使用场景
    - 适配器是有动机的修改了一个已经投产的接口，适配器模式适合进行在适配器中接受源数据处理转换为目标类型          
###迭代器模式
1. 定义
    - 提供了一种方法访问一个容器对象中的各个元素，而又不需暴露该对象的内部细节
2. 基本结构
    - Iterator抽象迭代器
    - ConcreteIterator具体迭代器
    - Aggregate抽象容器
    - Concrete Aggregate具体容器
3. 注意
    - 迭代器模式尽量不要自己写，JAVA提供的Iterator足够使用
###组合模式
1. 定义
    - 将对象组合成树形结构以表示部分-整体的层次结构，使得用户单个对象和组合对象的使用具有一致性
2. 基本结构
    - Component抽象构建角色
    - Leaf叶子构件
    - Composite树枝组件
3. 优点
    - 高层模块调用简单
    - 节点自由增加
4. 缺点
    - 组合模式有一个非常明显的缺点，就是直接使用了实现类，与面向接口编程是冲突的，即依赖倒置原则冲突
5. 使用场景
    - 维护和展示部分-整体关系的场景，如树形菜单，文件和文件夹管理
    - 从一个整体中能够独立出部分模块或功能的场景
6. 组合模式的种类
    - 安全模式：即组件的方法都会由内部处理，而不进行暴露
    - 透明模式：组件的方法暴露在抽象类或接口上
###观察者模式
1. 定义
    - 定义对象直接一对多的依赖关系，当被监察者发生活动时，相应的监察者能够得到通知并被自动更新
2. 基本结构
    - Subject 被观察者
    - Observer 观察者
    - ConcreteSubject 具体的被观察者
    - ConcreteObserver 具体的观察者
3. 优点
    - 观察者和被观察者直接是抽象耦合
    - 建立一套触发机制
4. 缺点
    - 观察者默认是按照顺序执行的，某一个流程卡壳，会影响其他观察者的执行
5. 使用场景
    - 关联行为场景，关联行为是可拆分的，而不是组合关系
    - 事件多级触发场景
    - 跨系统的消息交换场景，如消息队列的处理机制
6. 注意事项
    - 广播链的问题，尽量避免链过长的情况
    - 异步处理问题，可以使用消息队列和线程的方式去执行的消息，避免消息等待
    - 实际使用观察者模式时，只需要实现相关的Observer和Observable接口即可
7. 实际使用
    - 观察者和被观察者之间的消息沟通
    - 观察者响应模式：1.采用多线程方式 2.缓存技术
    - 被观察者尽量自己做主 ：根据实际情况判断是否告知观察者
###门面模式
1. 定义
    - 一个子系统的内部与外部通信必须通过一个统一的对象进行，门面模式提供一个高层次的接口，使得子系统更易使用
2. 基本结构
    - Facade门面角色
    - subsystem子系统角色
3. 优点
    - 减少系统的相互依赖
    - 提高了灵活性
    - 提高安全性
4. 缺点
    - 不符合开闭原则，对修改关闭，对扩展开放
5. 注意事项   
    - 子系统可以有多个门面，避免单个门面导致臃肿
    - 门面模式是不参与具体的业务逻辑的
###备忘录模式
1. 定义
    - 在不破坏封装性的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态
2. 基本结构
    - originator发起人角色
    - memento备忘录角色
    - Caretaker备忘录管理员角色
3. 使用场景
    - 需要保存和恢复数据的相关状态场景
    - 提供回滚操作
    - 数据库的事务就用的备忘录模式
4. 注意事项
    - 备忘录生命周期需要短时间，不可过长
    - 备忘录尽量避免对象数量过多，过大
5. 备忘录模式扩展
    - 多状态备份
    - 多版本备份                             
###访问者模式
1. 定义
    封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作
2. 基本结构
    - Visitor抽象访问者
    - ConcreteVisitor具体访问者
    - Element抽象元素
    - ConcreteElement具体元素
    - ObjectStructure结构对象   
3. 优点
    - 符合单一职责原则
    - 优秀的扩展性
    - 灵活性非常高
4. 缺点
    - 具体元素对访问者公布细节
    - 具体元素变更比较困难
    - 违背了依赖倒置原则    
5. 使用场景
    - 一个对象结构包含很多类对象，它们有不同的接口，想对这些对象实施一些依赖于其具体类的操作
    - 避免操作对象会对类进行污染，可以使用访问者模式
6. 扩展
    - 多个访问者，只需要新增实例即可 
###状态模式
1. 定义
    - 当一个对象内在状态改变时允许其改变其行为，这个对象看起来像改变了其类
2. 基本结构
    - State抽象状态的角色
    - ConcreteState具体状态的角色
    - Context 环境角色
3. 环境角色不成文约束
    - 把状态对象声明为静态常量，有几个状态对象就声明几个静态常量
    - 环境角色具有状态抽象角色定义的所有行为，具体执行使用委托形式
4. 优点
    - 结构清晰
    - 遵循设计原则，很好体现了开闭原则和单一职责原则
    - 封装性非常好
5. 缺点
    - 状态模式会导致类膨胀，可使用数据库表来解决该问题
6. 使用场景
    - 行为随状态改变而改变的场景
    - 条件、分支判断语句的替代者
###解释器模式
1. 定义
    - 一种按照规定语法进行解析的方案，给定一门语言，并定义一个解释器
2. 基本结构
    - AbstractExpression 抽象解释器
    - TerminalExpression 终结符表达式
    - NoTerminalExpression 非终结符表达式
    - Context 环境角色
3. 优点
    - 简单的语法分析工具
    - 扩展性显著，修改语法规则，只要修改相应的非终结符即可，扩展语法，只要增加非终结符即可
4. 缺点
    - 解释器模式会引起类膨胀
    - 解释器模式采用递归的调用方法，排错困难
    - 大量的循环和递归，导致效率低下
5. 场景
    - 简单的语法解释
###享元模式
1. 定义
    - 使用池技术进行共享对象
    - 内部状态:存储在享元对象内部不会随时间改变
    - 外部状态:唯一标识对象的ID 
2. 基本结构
    - Flyweight 抽象享元角色
    - ConcreteFlyweight具体享元角色
    - unsharedConcreteFlyweight 不可共享的享元角色
    - FlyweightFactory 享元工厂
3. 优点
    - 可以减少程序创建大量的对象
4. 使用场景
    - 系统存在大量的相似对象
    - 需要缓冲池的场景
###桥梁模式
1. 定义
    - 将抽象和实现解耦
                   
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
 
 